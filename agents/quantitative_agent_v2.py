"""
Ï†ïÎüâÏ†Å Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÏóêÏù¥Ï†ÑÌä∏ V2 - A2A ÌîÑÎ°úÌÜ†ÏΩú Í∏∞Î∞ò
Ï£ºÍ∞Ä, Í∏∞Ïà†Ï†Å ÏßÄÌëú, Ïû¨Î¨¥Ï†úÌëú Îì± Ï†ïÎüâÏ†Å Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÎäî ÏóêÏù¥Ï†ÑÌä∏
"""
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import yfinance as yf
import pandas as pd
import numpy as np

from fastapi import FastAPI
from contextlib import asynccontextmanager

from a2a_core.base.base_agent import BaseAgent
from a2a_core.protocols.message import A2AMessage, MessageType

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class QuantitativeAgentV2(BaseAgent):
    """Ï†ïÎüâÏ†Å Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù A2A ÏóêÏù¥Ï†ÑÌä∏"""
    
    def __init__(self):
        super().__init__(
            name="Quantitative Analysis Agent V2",
            description="Ï£ºÍ∞Ä, Í∏∞Ïà†Ï†Å ÏßÄÌëú, Ïû¨Î¨¥Ï†úÌëú Îì± Ï†ïÎüâÏ†Å Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÎäî A2A ÏóêÏù¥Ï†ÑÌä∏",
            port=8211
        )
        self.capabilities = [
            {
                "name": "quantitative_analysis",
                "version": "2.0",
                "description": "Ï£ºÏãùÏùò Ï†ïÎüâÏ†Å Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "ticker": {"type": "string", "description": "Ï£ºÏãù Ìã∞Ïª§"},
                        "period": {"type": "string", "description": "Î∂ÑÏÑù Í∏∞Í∞Ñ", "default": "1mo"}
                    },
                    "required": ["ticker"]
                },
                "output_schema": {
                    "type": "object",
                    "properties": {
                        "price_data": {"type": "object"},
                        "technical_indicators": {"type": "object"},
                        "fundamentals": {"type": "object"},
                        "risk_metrics": {"type": "object"}
                    }
                }
            }
        ]
    
    async def handle_message(self, message: A2AMessage):
        """Î©îÏãúÏßÄ Ï≤òÎ¶¨"""
        try:
            logger.info(f"üîç Î©îÏãúÏßÄ ÏàòÏã† - Type: {message.header.type}, Action: {message.body.action}")
            
            # Ïù¥Î≤§Ìä∏ Î©îÏãúÏßÄÎäî Î¨¥Ïãú
            if message.header.type == MessageType.EVENT:
                return
            
            # ÏöîÏ≤≠ Î©îÏãúÏßÄ Ï≤òÎ¶¨
            if message.header.type == MessageType.REQUEST and message.body.action == "quantitative_analysis":
                ticker = message.body.payload.get("ticker")
                period = message.body.payload.get("period", "1mo")
                
                if not ticker:
                    await self.send_response(
                        message,
                        self.create_response(
                            request_message=message,
                            success=False,
                            error="Ìã∞Ïª§Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§"
                        )
                    )
                    return
                
                logger.info(f"üìä Ï†ïÎüâÏ†Å Î∂ÑÏÑù ÏãúÏûë: {ticker} (Í∏∞Í∞Ñ: {period})")
                
                # Ï†ïÎüâÏ†Å Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÏàòÌñâ
                analysis_result = await self._analyze_quantitative_data(ticker, period)
                
                # ÏùëÎãµ Ï†ÑÏÜ°
                response_data = {
                    "ticker": ticker,
                    "analysis_date": datetime.now().isoformat(),
                    **analysis_result
                }
                
                # Ïù¥Î≤§Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
                await self._broadcast_analysis_complete(ticker, analysis_result)
                
                # ÏùëÎãµ Î©îÏãúÏßÄ ÏÉùÏÑ±
                await self.send_response(
                    message,
                    self.create_response(
                        request_message=message,
                        success=True,
                        result=response_data
                    )
                )
                
        except Exception as e:
            logger.error(f"‚ùå Ï†ïÎüâÏ†Å Î∂ÑÏÑù Ïã§Ìå®: {str(e)}")
            await self.send_response(
                message,
                self.create_response(
                    request_message=message,
                    success=False,
                    error=str(e)
                )
            )
    
    async def _analyze_quantitative_data(self, ticker: str, period: str) -> Dict:
        """Ï†ïÎüâÏ†Å Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÏàòÌñâ"""
        try:
            # yfinanceÎ•º ÏÇ¨Ïö©Ìïú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            stock = yf.Ticker(ticker)
            
            # 1. Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù
            price_data = self._analyze_price_data(stock, period)
            
            # 2. Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞
            technical_indicators = self._calculate_technical_indicators(stock, period)
            
            # 3. Ïû¨Î¨¥ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù
            fundamentals = self._analyze_fundamentals(stock)
            
            # 4. Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞
            risk_metrics = self._calculate_risk_metrics(stock, period)
            
            return {
                "price_data": price_data,
                "technical_indicators": technical_indicators,
                "fundamentals": fundamentals,
                "risk_metrics": risk_metrics
            }
            
        except Exception as e:
            logger.error(f"Î∂ÑÏÑù Ï§ë Ïò§Î•ò Î∞úÏÉù: {str(e)}")
            return {
                "error": str(e),
                "price_data": {},
                "technical_indicators": {},
                "fundamentals": {},
                "risk_metrics": {}
            }
    
    def _analyze_price_data(self, stock: yf.Ticker, period: str) -> Dict:
        """Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù"""
        try:
            # ÌòÑÏû¨ Í∞ÄÍ≤© Ï†ïÎ≥¥
            info = stock.info
            current_price = info.get('currentPrice', 0)
            
            # Í∏∞Í∞ÑÎ≥Ñ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞
            hist = stock.history(period=period)
            if hist.empty:
                return {"error": "Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§"}
            
            # Î≥ÄÌôîÏú® Í≥ÑÏÇ∞
            close_prices = hist['Close']
            change_1d = ((close_prices[-1] - close_prices[-2]) / close_prices[-2] * 100) if len(close_prices) > 1 else 0
            change_1w = ((close_prices[-1] - close_prices[-min(5, len(close_prices))]) / close_prices[-min(5, len(close_prices))] * 100) if len(close_prices) > 5 else 0
            change_1m = ((close_prices[-1] - close_prices[0]) / close_prices[0] * 100) if len(close_prices) > 20 else 0
            
            return {
                "current": float(current_price),
                "high_52w": float(info.get('fiftyTwoWeekHigh', 0)),
                "low_52w": float(info.get('fiftyTwoWeekLow', 0)),
                "change_1d": round(float(change_1d), 2),
                "change_1w": round(float(change_1w), 2),
                "change_1m": round(float(change_1m), 2),
                "volume": int(hist['Volume'][-1]) if not hist.empty else 0,
                "avg_volume": int(hist['Volume'].mean()) if not hist.empty else 0
            }
        except Exception as e:
            logger.error(f"Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {"error": str(e)}
    
    def _calculate_technical_indicators(self, stock: yf.Ticker, period: str) -> Dict:
        """Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞"""
        try:
            hist = stock.history(period="3mo")  # Îçî Í∏¥ Í∏∞Í∞Ñ Îç∞Ïù¥ÌÑ∞ ÌïÑÏöî
            if hist.empty:
                return {"error": "Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§"}
            
            close_prices = hist['Close']
            
            # RSI Í≥ÑÏÇ∞
            rsi = self._calculate_rsi(close_prices)
            
            # Ïù¥ÎèôÌèâÍ∑†
            ma_20 = float(close_prices.rolling(window=20).mean().iloc[-1]) if len(close_prices) >= 20 else float(close_prices.mean())
            ma_50 = float(close_prices.rolling(window=50).mean().iloc[-1]) if len(close_prices) >= 50 else float(close_prices.mean())
            ma_200 = float(close_prices.rolling(window=200).mean().iloc[-1]) if len(close_prices) >= 200 else None
            
            # MACD
            macd_signal = self._calculate_macd_signal(close_prices)
            
            # Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú
            bb_upper, bb_lower = self._calculate_bollinger_bands(close_prices)
            
            return {
                "rsi": round(float(rsi), 2),
                "macd_signal": macd_signal,
                "moving_avg_20": round(ma_20, 2),
                "moving_avg_50": round(ma_50, 2),
                "moving_avg_200": round(ma_200, 2) if ma_200 else None,
                "bollinger_upper": round(float(bb_upper), 2),
                "bollinger_lower": round(float(bb_lower), 2),
                "price_position": self._determine_price_position(float(close_prices.iloc[-1]), ma_20, ma_50)
            }
        except Exception as e:
            logger.error(f"Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ Ïò§Î•ò: {str(e)}")
            return {"error": str(e)}
    
    def _analyze_fundamentals(self, stock: yf.Ticker) -> Dict:
        """Ïû¨Î¨¥ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù"""
        try:
            info = stock.info
            
            return {
                "market_cap": self._format_large_number(info.get('marketCap', 0)),
                "pe_ratio": round(float(info.get('trailingPE', 0)), 2) if info.get('trailingPE') else None,
                "forward_pe": round(float(info.get('forwardPE', 0)), 2) if info.get('forwardPE') else None,
                "peg_ratio": round(float(info.get('pegRatio', 0)), 2) if info.get('pegRatio') else None,
                "ps_ratio": round(float(info.get('priceToSalesTrailing12Months', 0)), 2) if info.get('priceToSalesTrailing12Months') else None,
                "pb_ratio": round(float(info.get('priceToBook', 0)), 2) if info.get('priceToBook') else None,
                "dividend_yield": round(float(info.get('dividendYield', 0)) * 100, 2) if info.get('dividendYield') else 0,
                "earnings_growth": round(float(info.get('earningsQuarterlyGrowth', 0)) * 100, 2) if info.get('earningsQuarterlyGrowth') else None,
                "revenue_growth": round(float(info.get('revenueQuarterlyGrowth', 0)) * 100, 2) if info.get('revenueQuarterlyGrowth') else None,
                "profit_margin": round(float(info.get('profitMargins', 0)) * 100, 2) if info.get('profitMargins') else None,
                "debt_to_equity": round(float(info.get('debtToEquity', 0)) / 100, 2) if info.get('debtToEquity') else None
            }
        except Exception as e:
            logger.error(f"Ïû¨Î¨¥ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {"error": str(e)}
    
    def _calculate_risk_metrics(self, stock: yf.Ticker, period: str) -> Dict:
        """Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞"""
        try:
            hist = stock.history(period="1y")  # 1ÎÖÑ Îç∞Ïù¥ÌÑ∞Î°ú Í≥ÑÏÇ∞
            if hist.empty:
                return {"error": "Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§"}
            
            # ÏùºÎ≥Ñ ÏàòÏùµÎ•†
            returns = hist['Close'].pct_change().dropna()
            
            # Î≥ÄÎèôÏÑ± (Ïó∞ÌôòÏÇ∞)
            daily_volatility = returns.std()
            annual_volatility = daily_volatility * np.sqrt(252)
            
            # VaR (95% Ïã†Î¢∞ÏàòÏ§Ä)
            var_95 = np.percentile(returns, 5)
            
            # ÏµúÎåÄ ÎÇôÌè≠
            cumulative_returns = (1 + returns).cumprod()
            running_max = cumulative_returns.cummax()
            drawdown = (cumulative_returns - running_max) / running_max
            max_drawdown = drawdown.min()
            
            # ÏÉ§ÌîÑ ÎπÑÏú® (Î¨¥ÏúÑÌóò ÏàòÏùµÎ•† 2% Í∞ÄÏ†ï)
            risk_free_rate = 0.02
            excess_returns = returns.mean() * 252 - risk_free_rate
            sharpe_ratio = excess_returns / annual_volatility if annual_volatility > 0 else 0
            
            # Î≤†ÌÉÄ (S&P 500 ÎåÄÎπÑ)
            beta = self._calculate_beta(stock.ticker)
            
            return {
                "volatility": {
                    "daily": round(float(daily_volatility) * 100, 2),
                    "monthly": round(float(daily_volatility * np.sqrt(21)) * 100, 2),
                    "annual": round(float(annual_volatility) * 100, 2)
                },
                "var_95": round(float(var_95) * 100, 2),
                "max_drawdown": round(float(max_drawdown) * 100, 2),
                "sharpe_ratio": round(float(sharpe_ratio), 2),
                "beta": round(float(beta), 2) if beta else None,
                "risk_level": self._determine_risk_level(annual_volatility)
            }
        except Exception as e:
            logger.error(f"Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞ Ïò§Î•ò: {str(e)}")
            return {"error": str(e)}
    
    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> float:
        """RSI Í≥ÑÏÇ∞"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi.iloc[-1] if not rsi.empty else 50
    
    def _calculate_macd_signal(self, prices: pd.Series) -> str:
        """MACD Ïã†Ìò∏ Í≥ÑÏÇ∞"""
        exp1 = prices.ewm(span=12, adjust=False).mean()
        exp2 = prices.ewm(span=26, adjust=False).mean()
        macd = exp1 - exp2
        signal = macd.ewm(span=9, adjust=False).mean()
        
        if macd.iloc[-1] > signal.iloc[-1]:
            return "bullish"
        else:
            return "bearish"
    
    def _calculate_bollinger_bands(self, prices: pd.Series, period: int = 20) -> tuple:
        """Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Í≥ÑÏÇ∞"""
        ma = prices.rolling(window=period).mean()
        std = prices.rolling(window=period).std()
        upper = ma + (std * 2)
        lower = ma - (std * 2)
        return upper.iloc[-1], lower.iloc[-1]
    
    def _calculate_beta(self, ticker: str) -> Optional[float]:
        """Î≤†ÌÉÄ Í≥ÑÏÇ∞ (S&P 500 ÎåÄÎπÑ)"""
        try:
            stock = yf.Ticker(ticker)
            spy = yf.Ticker("SPY")
            
            stock_hist = stock.history(period="1y")['Close']
            spy_hist = spy.history(period="1y")['Close']
            
            stock_returns = stock_hist.pct_change().dropna()
            spy_returns = spy_hist.pct_change().dropna()
            
            # ÎÇ†Ïßú ÎßûÏ∂îÍ∏∞
            common_dates = stock_returns.index.intersection(spy_returns.index)
            stock_returns = stock_returns[common_dates]
            spy_returns = spy_returns[common_dates]
            
            covariance = np.cov(stock_returns, spy_returns)[0][1]
            spy_variance = np.var(spy_returns)
            
            return covariance / spy_variance if spy_variance > 0 else None
        except:
            return None
    
    def _determine_price_position(self, current_price: float, ma_20: float, ma_50: float) -> str:
        """Í∞ÄÍ≤© ÏúÑÏπò ÌåêÎã®"""
        if current_price > ma_20 and current_price > ma_50:
            return "Í∞ïÏÑ∏"
        elif current_price < ma_20 and current_price < ma_50:
            return "ÏïΩÏÑ∏"
        else:
            return "Ï§ëÎ¶Ω"
    
    def _determine_risk_level(self, volatility: float) -> str:
        """Î¶¨Ïä§ÌÅ¨ ÏàòÏ§Ä ÌåêÎã®"""
        if volatility < 0.15:
            return "ÎÇÆÏùå"
        elif volatility < 0.25:
            return "Î≥¥ÌÜµ"
        elif volatility < 0.35:
            return "ÎÜíÏùå"
        else:
            return "Îß§Ïö∞ ÎÜíÏùå"
    
    def _format_large_number(self, num: float) -> str:
        """ÌÅ∞ Ïà´Ïûê Ìè¨Îß∑ÌåÖ"""
        if num >= 1e12:
            return f"{num/1e12:.2f}T"
        elif num >= 1e9:
            return f"{num/1e9:.2f}B"
        elif num >= 1e6:
            return f"{num/1e6:.2f}M"
        else:
            return str(int(num))
    
    async def _broadcast_analysis_complete(self, ticker: str, result: Dict):
        """Î∂ÑÏÑù ÏôÑÎ£å Ïù¥Î≤§Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏"""
        event_data = {
            "ticker": ticker,
            "has_price_data": bool(result.get("price_data")),
            "has_technical": bool(result.get("technical_indicators")),
            "has_fundamentals": bool(result.get("fundamentals")),
            "has_risk_metrics": bool(result.get("risk_metrics")),
            "timestamp": datetime.now().isoformat()
        }
        
        await self.broadcast_event("quantitative_analysis_complete", event_data)
        logger.info(f"üì¢ Ï†ïÎüâÏ†Å Î∂ÑÏÑù ÏôÑÎ£å Ïù¥Î≤§Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏: {ticker}")
    
    async def on_start(self):
        """ÏóêÏù¥Ï†ÑÌä∏ ÏãúÏûë Ïãú Ïã§Ìñâ"""
        logger.info("‚úÖ Quantitative Analysis Agent V2 Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    async def on_stop(self):
        """ÏóêÏù¥Ï†ÑÌä∏ Ï¢ÖÎ£å Ïãú Ïã§Ìñâ"""
        logger.info("üëã Quantitative Analysis Agent V2 Ï¢ÖÎ£å Ï§ë...")


# ÏóêÏù¥Ï†ÑÌä∏ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
agent = QuantitativeAgentV2()

# BaseAgentÏùò appÏùÑ ÏÇ¨Ïö©
app = agent.app

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8211)